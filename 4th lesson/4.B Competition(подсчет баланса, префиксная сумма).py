"""
B. Соревнование
Жители Алгосов любят устраивать турниры по спортивному программированию. Все участники разбиваются на пары и соревнуются
друг с другом. А потом два самых сильных программиста встречаются в финальной схватке, которая состоит из нескольких
раундов. Если в очередном раунде выигрывает первый участник, в таблицу с результатами записывается 0, если второй, то 1.
 Ничьей в раунде быть не может.

Нужно определить наибольший по длине непрерывный отрезок раундов, по результатам которого суммарно получается ничья.
Например, если дана последовательность 0 0 1 0 1 1 1 0 0 0, то раунды с 2-го по 9-й (нумерация начинается с единицы)
дают ничью.

Формат ввода
В первой строке задаётся n (0 ≤ n ≤ 105) –— количество раундов. Во второй строке через пробел записано n чисел –— результаты раундов. Каждое число равно либо 0, либо 1.

Формат вывода
Выведите длину найденного отрезка.

"""


def competition():
    """
    Необходимо найти максимальную длину сбалансированной подпоследовательности в последовательности строк,
    состоящих из символов '0' и '1'

    Алгоритм, основан на подсчете баланса и хранении индексов последнего вхождения каждого значения баланса.
    Главное разобраться как находить баланс
    """

    nums = int(input())
    round_results = input().split()
    max_index = -1
    balance = 0
    index_by_score = {balance: max_index}
    max_length = 0

    for i, round in enumerate(round_results): # проходим по последовательности, если "1" то добавляет, если "0" отнимаем, достигаем т.о. баланса на текущий элемент
        if round == "1":
            balance = balance + 1
        else:
            balance = balance - 1

        if balance not in index_by_score: # ключами хеш-таблицы является счет, если этого счета ранее не было,
            # то сохраняем индекс, когда этот счет первый раз появился.
            index_by_score[balance] = i
        length = i - index_by_score[balance] # если ранее этот счет уже был,
            # то мы обновляем длину отрезка т.к. это означает, что длина "ничьи" может измениться

        if length > max_length:
            max_length = length

    return max_length


if __name__ == "__main__":
    print(competition())