"""
A. Расстояние по Левенштейну

Расстоянием Левенштейна между двумя строками s и t называется количество атомарных изменений, с помощью которых можно
одну строку превратить в другую. Под атомарными изменениями подразумеваются: удаление одного символа, вставка одного
символа, замена одного символа на другой.

Найдите расстояние Левенштейна для предложенной пары строк.

Выведите единственное число — расстояние между строками.

Формат ввода
В первой строке дана строка s, во второй — строка t. Длины обеих строк не превосходят 1000. Строки состоят из маленьких
латинских букв.

-- ПРИНЦИП РАБОТЫ --
Решение строится на принципах динамического программирования с помощью двумерной динамики.
* Что будет храниться в dp?  - в dp хранится матрица по количеству букв в строках.
* Каким будет базовый случай для задачи? - dp[0][0] = 0
* Каким будет переход динамики? - В каждую следующую клетку переходим выбирая минимальное предыдущее значение, то есть
из ячеек dp[i-1][j-1], либо dp[i][j-1], либо dp[i-1][j].
* Каким будет порядок вычисления данных в массиве dp? Чтобы посчитать значение в клетке dp[i,j], нужно знать предыдущие
значения dp[i−1][j-1], dp[i][j−1], dp[i-1]. То есть при вычислении та часть матрицы, которая находится выше и левее
ячейки (i,j), должна быть уже посчитана.
* Где будет располагаться ответ на исходный вопрос? Искомое значение будет содержаться в крайней нижней правой ячейке
dp[len(s)][len(t)]

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
в основе решения задачи лежит алгоритм Вагнера-Фишера, который строит матрицу для отслеживания минимальных операций между
подстроками. Мы вычисляем стоимость редактирования 2-х коротких несовпадающих слов(букв) добавляя единицу к текущему
минимальному балансу, если значения не совпадают, иначе, переносим минимальное значение дальше, когда доходим до
последней буквы получаем результат по всему слову.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
O(st), где s — длина 1-ой строки, t - длина 2-ой строки.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
O(st), где s — длина 1-ой строки, t - длина 2-ой строки.

-- ID успешной посылки --
https://contest.yandex.ru/contest/25597/run-report/120782420/

"""


def find_levenshtein_distance(s, t):
    len_s = len(s)
    len_t = len(t)
    dp = [[0] * (len_t + 1) for i in range(len_s + 1)]

    dp[0] = [i for i in range(len_t + 1)]

    for j in range(len_s + 1):
        dp[j][0] = j

    for i in range(1, len_s + 1):
        for j in range(1, len_t + 1):
            if s[i-1] == t[j-1]:
                dp[i][j] = dp[i-1][j-1]

            else:
                dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i-1][j-1] + 1)

    print(dp)
    return dp[len_s][len_t]


def main():
    s = input()
    t = input()
    return find_levenshtein_distance(s, t)


if __name__ == "__main__":
    print(main())