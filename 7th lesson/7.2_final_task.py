"""
B. Одинаковые суммы

На Алгосах устроили турнир по настольному теннису. Гоша выиграл n партий, получив при этом некоторое количество очков
за каждую из них.

Гоше стало интересно, можно ли разбить все заработанные им во время турнира очки на две части так, чтобы сумма в них
была одинаковой.

Формат ввода
В первой строке записано целое число n (0 ≤ n ≤ 300) –— количество выигранных партий.

Во второй строке через пробел записано n целых неотрицательных чисел, каждое из которых не превосходит
300 –— заработанные в партиях очки.

Формат вывода
Нужно вывести True, если произвести такое разбиение возможно, иначе —– False

-- ПРИНЦИП РАБОТЫ --
Работает на принципах динамического программирования. Мы создаем массив dp размером с ту сумму, которую ищем. И будем
проверять можем ли мы достичь эту сумму. Ответ будет храниться в последнем элементе массива dp.
Основная часть алгоритма заключается в 2х циклах. Во внешнем цикле мы проходим по результатам турниров. Во внутреннем
цикле проходим по возможным суммам, для этого мы идем с конца до числа. Например, сумма, которую нужно набрать 7, а
результат турнира 5, мы будем проверять суммы от 7 до 5. Создаем проверку, можем ли мы вычесть текущий элемент из суммы,
если < 0, то мы не можем получить сумму, которая нам нужна. Обновляем массив dp от target до num в обратном порядке

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Мы находим искомое число, для того чтобы сумма в двух подмножествах была одинаковой, и с помощью динимического
программирования, массива dp, проверяем возможно ли собрать такую сумму из введенных значений. Если мы
можем найти такие сумму, то такое разбиение возможно.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
O(n^2), где n - кол-во турниров

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
O(n), , где n - кол-во турниров

-- ID успешной посылки --
https://contest.yandex.ru/contest/25597/run-report/120872724/

"""


def is_same_sum(n, game_results):
    total_sum = sum(game_results)

    if total_sum % 2 != 0:
        return False

    target = total_sum // 2

    dp = [False] * (target + 1)
    dp[0] = True

    for num in game_results:
        for j in reversed(range(num, target + 1)):
            if j - num >= 0:
                dp[j] = dp[j] or dp[j - num]
    return dp[target]


def main():
    n = int(input())
    game_results = list(map(int, (input().split())))
    return is_same_sum(n, game_results)


if __name__ == "__main__":
    print(main())
