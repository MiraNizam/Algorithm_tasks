"""
B. Шпаргалка

Вася готовится к экзамену по алгоритмам и на всякий случай пишет шпаргалки.

Чтобы уместить на них как можно больше информации, он не разделяет слова пробелами. В итоге получается одна очень
длинная строка. Чтобы на самом экзамене из-за нервов не запутаться в прочитанном, он просит вас написать программу,
которая по этой длинной строке и набору допустимых слов определит, можно ли разбить текст на отдельные слова из набора.

Более формально: дан текст T и набор строк s1, ... ,sn. Надо определить, представим ли T как sk1sk2...skr, где ki —
индексы строк. Индексы могут повторяться. Строка si может встречаться в разбиении текста T произвольное число раз.
Можно использовать не все строки для разбиения. Строки могут идти в любом порядке.

Формат ввода
В первой строке дан текст T, который надо разбить на слова. Длина T не превосходит 100100. Текст состоит из строчных
букв английского алфавита.

Во второй строке записано число допустимых к использованию слов 1 ≤ n ≤ 100.

В последующих n строках даны сами слова, состоящие из маленьких латинских букв. Длина каждого слова не превосходит 100.

Формат вывода
Выведите «YES», если текст можно разбить на слова из данного словаря, или «NO» в ином случае.


-- ПРИНЦИП РАБОТЫ --
Задача сводится к поиску строк в шаблоне, это удобно выполнить через префиксное дерево. Префиксное дерево будет
содержать все допустимые слова, которые поступили на вход, так мы проверим есть ли подстроки строки Т в словаре.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Для решения задачи использована структура данных - префиксное дерево и метод динамического программирования.
Префиксное дерево хранит словарь, а в массиве dp будем хранить значение True, если подстрока t[0:i] может быть разбита
на слова.
-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
O(t^2), где t - длина текста

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
O(n + t), где n - длина слов в словаре, t - длина текста

-- ID успешной посылки --
https://contest.yandex.ru/contest/26133/run-report/123689146/


"""


class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True


def is_split_string(t: str, words: list) -> str:
    trie = Trie()
    for word in words:
        trie.insert(word)

    len_t = len(t)
    dp = [False] * (len_t + 1)
    dp[0] = True

    for i in range(len_t):
        node = trie.root
        if dp[i]:
            for j in range(i, len_t + 1):
                if node.is_end_of_word:
                    dp[j] = True
                if j == len_t or t[j] not in node.children:
                    break
                node = node.children[t[j]]

    return "YES" if dp[len_t] else "NO"


def main() -> str:
    t = input()
    n = int(input())
    words = [input() for _ in range(n)]

    result = is_split_string(t, words)
    return result


if __name__ == "__main__":
    print(main())
